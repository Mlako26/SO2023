Primero, la funcion de inicializacion hace exactamente eso. Pide el numero major para el driver, y en caso de no conseguirlo procede a devolver un error. Luego, le pide al Sistema Operativo memoria en el kernel, exactamente 1 byte, sobre el que pone el caracter 0. En caso de no conseguir la memoria, devuelve el major y un codigo de error.
El open y el release parecerian aumentar y decrementar respectivamente la cantidad de usuarios utilizando el driver.

Por otro lado, las operaciones de read y write parecerian mas complicadas.
Para el write, se genera un puntero a char tmp, el cual apunta al comienzo de la data que quiere escribir el usuario + count - 1. Ya que count es la cantidad de caracteres en el buffer a escribir, hacer esta operación deja a tmp parado en el último caracter del buffer. Luego, escribe ese mismo caracter en la memoria del driver. Siempre retorna 1 ya que escribe siempre 1 byte.

Para el read, se le copia al usuario el unico caracter que hay en memoria dinamica almacenado. Luego, está la variable offset, la cual si se encuentra en 0 la pone en 1 y se devuelve un 1, y en caso contrario un 0. Es decir, la funcion devuelve exactamente la cantidad de caracteres leidos. Si el offset estaba en 0, y se quizo leer la primera posicion de la memoria dinamica, entonces se lee ese byte, se aumenta el offset y se devuelve un 1 indicando que se leyó un byte nuevo. Si el offset no fuese 0, se intentaría leer bytes más adelante que el único byte en memoria_buffer, con lo cual se vuelve a escribir el mismo byte en buff, y se retorna 0, indicando que no se leyó ningún caracter nuevo.
